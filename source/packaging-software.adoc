[[packaging-software]]
= Программное обеспечение для упаковки

[[rpm-packages]]
== RPM-пакеты

В этом разделе рассматриваются основы cборки RPM-пакетов. Дополнительные сведения находятся в разделе
xref:advanced-topics[Дополнительные материалы].

[[what-is-an-rpm]]
=== Что такое RPM-пакет?

RPM-пакет - это архив, содержащий в себе архив https://en.wikipedia.org/wiki/Cpio[.cpio] с файлами (скомпилированные исполняемые файлы, библиотеки и данные), а также метаданные - имя пакета, его описание, зависимости и т.д. Менеджер пакетов RPM использует эти метаданные для проверки наличия необходимых пакетов из списка зависимостей, исполнения инструкций по установке файлов и сохранения общей информации о пакете у себя в базе.

Существует два типа RPM-пакетов:

* SRPM-пакеты (исходники) - архив с расширением `.src.rpm` 
* RPM-пакеты (бинарники) - архив с расширением `.rpm`

SRPM и RPM-пакеты имеют общий формат и инструментарий, но имеют разное содержимое и служат разным целям. SRPM содержит исходный код, при необходимости патчи к нему и spec-файл, в котором описывается, как собрать исходный код в бинарный RPM-пакет. Бинарный RPM-пакет содержит бинарные файлы, созданные из исходных текстов и патчей, если таковые имелись.

[[rpm-packaging-tools]]
=== Инструменты для сборки RPM-пакетов

Пакет``rpmdevtools``, установленный на этапе xref:prerequisites[Необходимые пакеты], предоставляет несколько утилит для сборки RPM-пакетов. Чтобы перечислить эти утилиты, выполните в консоли следующую команду:

[source,bash]
----
$ rpm -ql rpmdevtools | grep bin

----

Для получения дополнительной информации о вышеуказанных утилитах см. их страницы руководства или диалоговые окна справки.
/
[[rpm-packaging-workspace]]
=== Рабочее пространство для сборки RPM-пакетов

Чтобы создать дерево каталогов, которое является рабочей областью сборки RPM-пакетов, используйте утилиту ``rpmdev-setuptree``:

[source,bash]
----
$ rpmdev-setuptree

$ tree ~/rpmbuild/
/home/user/rpmbuild/
|-- BUILD
|-- RPMS
|-- SOURCES
|-- SPECS
 -- SRPMS

----

Созданные каталоги служат следующим целям:

[cols="20%,80%"]
|====
| Каталог | Назначение
| BUILD     | Содержит все файлы, которые появляются при сборке пакета.
| RPMS      | Здесь появляются готовые бинарные RPM-пакеты (`.rpm`), в подкаталогах для разных архитектур, например, в подкаталогах``x86_64`` и ``noarch``.
| SOURCES   | Здесь находятся архивы исходного кода и патчи. Утилита ``rpmbuild`` ищет их здесь.
| SPECS     | Здесь хранятся spec-файлы.
| SRPMS     | Здесь находятся пакеты с исходниками (`.src.rpm`).
|====

[[what-is-a-spec-file]]
=== Что такое SPEC-файл?

Spec-файл можно рассматривать как "инструкцию", который утилита ``rpmbuild`` использует для фактической сборки RPM-пакет. Он сообщает системе сборки, что делать, определяя инструкции в серии разделов. Разделы определены в __Преамбуле__ и в __Основной части__. __Преамбула__ содержит ряд элементов метаданных, которые используются в __Основной части__. Тело содержит основную часть инструкций.

[[spec-example]]
=== Пример .spec-файла

Данный пример взять из https://www.altlinux.org/SampleSpecs/program[ALT Linux Wiki].

[source,bash]
----
Name: sampleprog
Version: 1.0
Release: alt1

Summary: Sample program specfile
Summary(ru_RU.UTF-8): Пример спек-файла для программы

License: GPLv2+
Group: Development/Other
Url: http://www.altlinux.org/SampleSpecs/program

Packager: Sample Packager <sample@altlinux.org>

Source: %name-%version.tar
Patch0: %name-1.0-alt-makefile-fixes.patch

%description
This specfile is provided as sample specfile for packages with programs.
It contains most of usual tags and constructions used in such specfiles.

%description -l ru_RU.UTF-8
Этот спек-файл является примером спек-файла для пакета с программой. Он содержит
основные теги и конструкции, используемые в подобных спек-файлах.

%prep
%setup
%patch0 -p1

%build
%configure
%make_build

%install
%makeinstall_std
%find_lang %name

%files -f %name.lang
%doc AUTHORS ChangeLog NEWS README THANKS TODO contrib/ manual/
%_bindir/*
%_man1dir/*

%changelog
* Sat Sep 33 3001 Sample Packager <sample@altlinux.org> 1.0-alt1
- initial build

----





[[preamble-items]]
==== Пункты преамбулы

В этой таблице перечислены элементы, используемые в разделе преамбулы файла спецификации RPM:

[cols="30%,70%"]
|====
| SPEC Директива   | Определение
| ``Name``          | Базовое имя пакета, которое должно совпадать с именем spec-файла.
| ``Version``       | Версия upstream-кода.
| ``Release``       | Релиз пакета используется для указания номера сборки пакета при данной версии upstream-кода. Как правило, установите начальное `alt1`  и увеличивайте его с каждым новым выпуском пакета, например: alt1, alt2, alt3 и т.д. Сбросьте значение до alt1 при создании новой версии программного обеспечения.
| ``Summary``       | Краткое, в одну строку, описание пакета.
| ``License``       | Лицензия на собираемое программное обеспечение.
| ``Group``         | Используется для указания категории, к которой относится пакет. Указанная группа должна находиться в списке групп, известном RPM. Этот список располагается в файле /usr/lib/rpm/GROUPS, идущим вместе с пакетом rpm.
| ``URL``           | Полный URL-адрес для получения дополнительной информации о программе. Чаще всего это ссылка на *GitHub* upstream-проекта для собираемого программного обеспечения.
| ``Source0``       | Путь или URL-адрес к сжатому архиву исходного кода (не исправленный, исправления обрабатываются в другом месте). Этот раздел должен указывать на доступное и надежное хранилище архива, например, на upstream-страницу, а не на локальное хранилище сборщика. При необходимости можно добавить дополнительные исходные директивы, каждый раз увеличивая их количество, например: Source1, Source2, Source3 и так далее.
| ``Patch0``        | Название первого патча, который при необходимости будет применен к исходному коду. При необходимости можно добавить дополнительные директивы PatchX, увеличивая их количество каждый раз, например: Patch1, Patch2, Patch3 и так далее.
| ``BuildArch``     | Если пакет не зависит от архитектуры, например, если он полностью написан на интерпретируемом языке программирования, установите для этого значение ``BuildArch: noarch``. Если этот параметр не задан, пакет автоматически наследует архитектуру компьютера, на котором он собран, например ``x86_64``.
| ``BuildRequires`` | Разделённый запятыми или пробелами список пакетов, необходимых для сборки программы. Может быть несколько записей ``BuildRequires``, каждая в отдельной строке в SPEC файле. 
| ``Requires`` | Разделённый запятыми или пробелами список пакетов, необходимых программному обеспечению для запуска после установки. Это его *зависимости* Может быть несколько записей ``Requires``, каждая в отдельной строке в SPEC файле.
| ``ExcludeArch``   | Если часть программного обеспечения не может работать на определенной архитектуре процессора, Вы можете исключить эту архитектуру здесь.
|====

Директивы ``Name``, ``Version`` и ``Release`` содержат имя RPM-пакета. Эти три директивы часто называют **N-V-R** или **NVR**, поскольку имена RPM-пакета имеют формат ``NAME-VERSION-RELEASE``.


Вы можете получить пример ``NAME-VERSION-RELEASE``, выполнив запрос с использованием ``rpm`` для конкретного пакета:

[source,bash]
----
$ rpm -q rpmdevtools
rpmdevtools-8.10-alt2.noarch

----

Здесь ``rpmdevtools`` - это имя пакета, ``8.10`` - версия, а ``alt2`` - релиз. Последний маркер ``noarch`` - сведения об архитектуре.
В отличие от NVR, маркер архитектуры не находится под прямым управлением сборщика, а определяется средой сборки ``rpmbuild``. Исключением из этого правила является архитектурно-независимый пакет ``noarch``.

[[body-items]]
==== Составляющие основной части

В этой таблице перечислены элементы, используемые в теле файла спецификации RPM-пакета:

[cols="20%,80%"]
|====
| SPEC Директива   | Определение
| ``%description`` | Полное описание программного обеспечения, входящего в комплект поставки RPM. Это описание может занимать несколько строк и может быть разбито на абзацы.
| ``%prep``        | Команда или серия команд для подготовки программного обеспечения к сборке, например, распаковка архива из Source0. Эта директива может содержать сценарий оболочки (shell скрипт).
| ``%build``       | Команда или серия команд для фактической сборки программного обеспечения в машинный код (для скомпилированных языков) или байт-код (для некоторых интерпретируемых языков).
| ``%install``     | Раздел, который во время сборки пакета эмулирует конечные пути установки файлов в систему. Команда или серия команд для копирования требуемых артефактов сборки из ``%builddir`` (где происходит сборка) в``%buildroot`` каталог (который содержит структуру каталогов с файлами, подлежащими сборке). Обычно это означает копирование файлов из ``~/rpmbuild/BUILD`` в ``~/rpmbuild/BUILDROOT`` и создание необходимых каталогов ``~/rpmbuild/BUILDROOT``.  Это выполняется только при создании пакета, а не при установке пакета конечным пользователем. Подробности см. в разделе xref:working-with-spec-files[Работа со SPEC файлом].
| ``%check``       | Команда или серия команд для тестирования программного обеспечения. Обычно включает в себя такие вещи, как модульные тесты.
| ``%files``       | Список файлов, которые будут установлены в системе конечного пользователя.
| ``%changelog``   | Запись изменений, произошедших с пакетом между различными ``Version`` или ``Release`` сборками.
|====

NOTE: Конструкция `%setup` в Sisyphus RPM использует флаг `-q` (quiet) по умолчанию. Запись %setup -q и %setup - полностью идентичны. Если использовать конструкцию с флагом `-v`, то будет выведена дополнительная информация в логах сборки  

////
[[advanced-items]]
==== Дополнительные элементы 

Файл спецификации также может содержать дополнительные элементы. Например, файл спецификации может содержать __скриптлеты_ и __триггеры__. Они вступают в силу в разные моменты процесса установки в системе конечного пользователя (не в процессе сборки).

Дополнительную информацию см.  xref:triggers-and-scriptlets[Триггеры и скриптлеты].

[[buildroots]]
=== BuildRoots

В контексте упаковки RPM "buildroot" - это среда 
ifdef::community[https://en.wikipedia.org/wiki/Chroot[chroot]]
ifdef::rhel[chroot]
Это означает, что артефакты сборки размещаются здесь с использованием той же иерархии файловой системы, что и в системе конечного пользователя, при этом "buildroot" выступает в качестве корневого каталога. Размещение артефактов сборки должно соответствовать стандарту иерархии файловой системы конечного пользователя.

Файлы в "buildroot" позже помещаются в архив
ifdef::community[https://en.wikipedia.org/wiki/Cpio[cpio]]
ifdef::rhel[cpio]
, который становится основной частью RPM. Когда RPM устанавливается в системе конечного пользователя, эти файлы извлекаются в корневой каталог, сохраняя правильную иерархию.

[NOTE]
====
// Ранее было рекомендовано либо определять макрос `%buildroot` в каталоге `~/.rpmmacros`, либо определять тег `BuildRoot` непосредственно в SPEC файле. 
Начиная с выпуска Red Hat Enterprise Linux 6, программа `rpmbuild` имеет свои собственные значения макросов по умолчанию. Поскольку переопределение этих значений по умолчанию приводит к ряду проблем, Red Hat не рекомендует определять собственное значение этого макроса. Вы можете использовать макрос 
`%{buildroot}`  с параметрами по умолчанию из каталога `rpmbuild`.
====


[[working-with-spec-files]]
=== Работа со SPEC файлами

Большая часть упаковки программного обеспечения в RPMs - это редактирование файла спецификации. В этом разделе мы обсудим, как создать и изменить SPEC файл.

Чтобы упаковать новое программное обеспечение, Вам необходимо создать новый файл спецификации. Вместо того, чтобы писать его вручную с нуля, используйте утилиту ``rpmdev-newspec``. Она создаёт незаполненный файл спецификации, и Вы заполняете необходимые директивы и поля.

В этом руководстве мы используем три примера реализации программы 'Hello
World!', созданной при подготовке xref:preparing-software-for-packaging[программного обеспечения для упаковки]:

*   https://github.com/altlinux/alt-packaging-guide/blob/master/example-code/bello-0.1.tar.gz?raw=true[bello-0.1.tar.gz]

*   https://github.com/altlinux/alt-packaging-guide/blob/master/example-code/pello-0.1.2.tar.gz?raw=true[pello-0.1.2.tar.gz]

*   https://github.com/altlinux/alt-packaging-guide/blob/master/example-code/cello-1.0.tar.gz?raw=true[cello-1.0.tar.gz]

**   https://github.com/altlinux/alt-packaging-guide/blob/master/example-code/cello-output-first-patch.patch[cello-output-first-patch.patch]

Переместите их в ``~/rpmbuild/SOURCES``.

Создайте SPEC файл для каждой из трёх программ:

NOTE: Некоторые текстовые редакторы, ориентированные на программистов, предварительно заполняют новый ``.spec`` файл с их собственным шаблоном спецификации. ``rpmdev-newspec`` предоставляет независимый от редактора метод, именно поэтому он используется в этом руководстве.

[source,bash]
----
$ cd ~/rpmbuild/SPECS

$ rpmdev-newspec bello
bello.spec created; type minimal, rpm version >= 4.11.

$ rpmdev-newspec cello
cello.spec created; type minimal, rpm version >= 4.11.

$ rpmdev-newspec pello
pello.spec created; type minimal, rpm version >= 4.11.

----

``~/rpmbuild/SPECS/`` каталог теперь имеет три SPEC файла с именами
``bello.spec``, ``cello.spec``, и ``pello.spec``.

Изучите файлы. Директивы в них представляют собой директивы, описанные в разделе
xref:what-is-a-spec-file[Что такое SPEC файл].  В следующих разделах Вы заполните эти файлы спецификаций.

ifdef::community[]
[NOTE]
====
Утилита ``rpmdev-newspec`` не использует рекомендации или соглашения, характерные для какого-либо конкретного дистрибутива Linux. Однако этот документ предназначен для Fedora, CentOS и RHEL, поэтому В ы заметите, что:

* Используйте ``rm $RPM_BUILD_ROOT`` при сборке на  _CentOS_ (версии, предшествующие версии 7.0)
или на https://getfedora.org/[Fedora] (версии, предшествующие версии 18).

* Мы предпочитаем использовать обозначение ``%{buildroot}`` вместо ``$RPM_BUILD_ROOT`` при обращении к Buildroot RPM для обеспечения согласованности со всеми другими определенными или предоставленными макросами во всем файле спецификации..

====
endif::community[]

ifdef::rhel[]
[NOTE]
====
Утилита ``rpmdev-newspec`` не использует рекомендации или соглашения, характерные
для какого-либо конкретного дистрибутива Linux. Однако этот документ ориентирован на RHEL, поэтому
вы заметите, что мы предпочитаем использовать нотацию ``%{buildroot}``, а не
``$RPM_BUILD_ROOT`` при ссылке на Buildroot RPM для обеспечения согласованности со всеми другими определенными или предоставленными макросами во всем файле спецификации.

====
endif::rhel[]

Ниже приведены три примера. Каждый из них полностью описан, так что вы можете перейти к конкретному, если он соответствует вашим потребностям в упаковке. Или прочтите их все, чтобы полностью изучить упаковку различных видов программного обеспечения.

[cols="15%,85%"]
|====
| Имя программы | Объяснение примера
| bello         | Программа, написанная на необработанном интерпретируемом языке программирования. Пример демонстрирует, когда исходный код не нужно собирать, а нужно только установить. Если необходимо упаковать предварительно скомпилированный бинарный файл, Вы также можете использовать этот метод.
| pello         | Программа, написанная на интерпретируемом языке программирования с последующей байт-компиляцией. Пример демонстрирует байт-компиляцию исходного кода и установку байт-кода - результирующих, предварительно оптимизированных файлов.
| cello         | Программа, написанная на изначально скомпилированном языке программирования. Пример демонстрирует общий процесс компиляции исходного кода в машинный код и установки результирующих исполняемых файлов.
|====



[[bello-working-with-spec-files]]
==== bello

Первый SPEC файл создан для bash скрипта ``bello`` из раздела
xref:preparing-software-for-packaging[Подготовка программного обеспечения для упаковки].

Убедитесь, что у вас есть:

. Переместите исходный код ``bello`` в ``~/rpmbuild/SOURCES/``.  См. 
xref:working-with-spec-files[Работа со SPEC файлом].

. Теперь создайте пустой SPEC файл``~/rpmbuild/SPECS/bello.spec``. Файл будет иметь следующее содержание:
+
[source,specfile]
----
Name:           bello
Version:
Release:        1%{?dist}
Summary:

License:
URL:
Source0:

BuildRequires:
Requires:

%description

%prep
%setup -q

%build
%configure
make %{?_smp_mflags}

%install
rm -rf $RPM_BUILD_ROOT
%make_install

%files
%doc

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org>
-

----

Теперь измените ``~/rpmbuild/SPECS/bello.spec`` для создания RPMs пакета  ``bello``:

. Заполните поля``Name``, ``Version``, ``Release``, и ``Summary`` :
+
* Поле ``Name`` уже было указано в качестве аргумента для  ``rpmdev-newspec``.
+
* Установите  ``Version`` в соответствии с “upstream” версией исходного кода ``bello``, ``0.1``.
+
*  ``Release`` автоматически установит ``1%{?dist}``, что изначально равно 
``1``. Увеличивайте это значение при каждом обновлении пакета без изменения ``Version``, например, при добавлениии патча.
Сбросьте ``Release`` до ``1``, когда произойдёт новый выпуск новой версии программы. Например, если будет выпущена bello версии ``0.2``. Макрос _disttag_ более подробно описан в части про
xref:rpm-macros[].
+
* ``Summary`` - это краткое, однострочное объяснение того, что представляет собой это программное обеспечение.
+
После Ваших изменений первый раздел SPEC файла примет следующий вид:
+
[source,specfile]
----
Name:           bello
Version:        0.1
Release:        1%{?dist}
Summary:        Hello World example implemented in bash script

----
+
. Заполните поля ``License``, ``URL``, и ``Source0``:
+
* Поле ``License`` это
ifdef::community[https://en.wikipedia.org/wiki/Software_license[Лицензия на программное обеспечение]]
ifdef::rhel[Лицензия на программное обеспечение]
связанная с исходным кодом из upstream-выпуска.
+
ifdef::community[]
Для корректного заполнения поля ``License``, обратитесь к:
https://fedoraproject.org/wiki/Licensing:Main[Fedora Руководство по лицензированию]

endif::community[]
+
Например, используйте ``GPLv3+``.
+
* Поле URL - это URL-адрес страницы upstream-программного обеспечения. Для примера, используем 
``https://example.com/bello``. В данном поле рекомендуется использовать макрос %{name}, тогда адрес примет следующий вид: ``https://example.com/%{name}``.
+
* Поле ``Source0`` содержит URL-адрес  upstream-исходного кода программного обеспечения. Он должен быть напрямую связан с версией программного обеспечения, которое упаковывается. В этом примере мы можем использовать ``https://example.com/bello/releases/bello-0.1.tar.gz``.
Используйте макросы %{name} и %{version} для учета изменений в версии. В результате адрес примет вид:
``https://example.com/%{name}/releases/%{name}-%{version}.tar.gz``.
+
После Ваших изменений первая секция SPEC файла примет вид:
+
[source,specfile]
----
Name:           bello
Version:        0.1
Release:        1%{?dist}
Summary:        Hello World example implemented in bash script

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

----
+

. Заполните директивы ``BuildRequires`` и ``Requires`` и подключите директиву ``BuildArch``:
+

* ``BuildRequires``- определяет зависимости для пакета во время сборки. Для ``bello`` нет этапа сборки, потому что bash - это интерпретируемый язык программирования, и файлы просто устанавливаются в их расположение в системе. Просто удалите эту директиву. 
+
* ``Requires`` задает зависимости для пакета во время выполнения, то-есть, необходимые пакеты для работы программы.   Для выполнения скрипта ``bello``
требуется только оболочка  ``bash``, поэтому укажите bash в этой директиве.
+
* Поскольку это программное обеспечение, написанное на интерпретируемом языке программирования без скомпилированных расширений, добавьте директиву ``BuildArch`` со значением``noarch``. Это говорит RPM о том, что этот пакет не нужно привязывать к архитектуре процессора, на которой он построен.
+
После Ваших изменений первая секция SPEC файла примет вид:
+
[source,specfile]
----
Name:           bello
Version:        0.1
Release:        1%{?dist}
Summary:        Hello World example implemented in bash script

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

Requires:       bash

BuildArch:      noarch

----
. Заполните поля ``%description``, ``%prep``, ``%build``, ``%install``,
``%files``, and ``%license``. Эти директивы являются заголовками секций, поскольку они определяют многостроковые, скриптовые или состоящие из нескольких инструкций задачи.
* ``%description`` - это более длинное и полное описание программного обеспечения, чем ``Summary``, содержащее один или несколько абзацев. В нашем примере мы будем использовать только краткое описание.
+
* В разделе ``%prep`` указывается, как подготовить среду сборки. Обычно это включает в себя расширение сжатых архивов исходного кода, применение исправлений и, возможно, анализ информации, предоставленной в исходном коде, для использования в следующей части SPEC файла. В этом разделе мы просто используем встроенный макрос ``%setup -q``.
+
* Секция ``%build`` определяет, как на самом деле создавать программное обеспечение, которое мы упаковываем. Однако, поскольку ``bash`` не нужно создавать, просто удалите то, что было предоставлено шаблоном, и оставьте этот раздел пустым.
+
* Секция ``%install`` содержит инструкции для ``rpmbuild``  о том, как установить программное обеспечение после его сборки в каталог ``BUILDROOT``. Этот каталог представляет собой пустой базовый каталог
ifdef::community[https://en.wikipedia.org/wiki/Chroot[chroot]]
ifdef::rhel[chroot]
,который напоминает корневой каталог конечного пользователя. Здесь мы должны создать любые каталоги, которые будут содержать установленные файлы.
+
Поскольку для установки ``bello`` нам нужно только создать каталог назначения и установить туда исполняемый ``bash`` скрипт, мы будем использовать команду  ``install``. Макросы RPM позволяют нам делать это без жесткого кодирования путей.
+
Секция ``%install`` после Ваших изменений должен выглядеть следующим образом:
+
[source,specfile]
----
%install

mkdir -p %{buildroot}/%{_bindir}

install -m 0755 %{name} %{buildroot}/%{_bindir}/%{name}

----
+
* В секци ``%files`` указывается список файлов, предоставляемых этим RPM, и их полный путь в системе конечного пользователя. Следовательно, путь устанавливаемого файла ``bello`` - это ``/usr/bin/bello``, или, с помощью макросов RPM, 
``%{_bindir}/%{name}``.
+
В этом разделе Вы можете указать роль различных файлов с помощью встроенных макросов. Это полезно для запроса метаданных с помощью команд
``rpm``. Например, чтобы указать, что файл  LICENSE является файлом лицензии на программное обеспечение, мы используем макрос %license.
+
После изменения, секция``%files`` примет следующий вид:
+
[source,specfile]
----
%files
%license LICENSE
%{_bindir}/%{name}

----
+
. Последняя секция, ``%changelog``, представляет собой список записей с отметкой даты для каждой версии выпуска пакета. Они регистрируют изменения упаковки, а не изменения программного обеспечения. Примеры изменений упаковки: добавление исправления, изменение процедуры сборки в ``%build``.
+
Следуйте следующему формату для первой строки:
+
`* Day-of-Week Month Day Year Name Surname <email> - Version-Release`
+
Следуйте данным правилам для фактической записи изменений:
+
--
* Каждая запись об изменении может содержать несколько элементов - по одному для каждого изменения
* Каждый элемент начинается с новой строки.
* Каждый элемент начинается с символа ``-``.
--
+
Пример записи с отметкой даты
+
[source,specfile]
----
%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1-1
- First bello package
- Example second item in the changelog for version-release 0.1-1

----

Вы написали целый файл спецификации **bello**. Послный SPEC файл **bello** теперь выглядит так:

[source,specfile]
----
Name:           bello
Version:        0.1
Release:        1%{?dist}
Summary:        Hello World example implemented in bash script

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

Requires:       bash

BuildArch:      noarch

%description
The long-tail description for our Hello World Example implemented in
bash script.

%prep
%setup -q

%build

%install

mkdir -p %{buildroot}/%{_bindir}

install -m 0755 %{name} %{buildroot}/%{_bindir}/%{name}

%files
%license LICENSE
%{_bindir}/%{name}

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1-1
- First bello package
- Example second item in the changelog for version-release 0.1-1

----

В следующем разделе рассказывается о том, как собрать RPM.

[[pello-working-with-spec-files]]
==== pello

Наш второй SPEC будет для примера, написанного на языке программирования https://www.python.org/[Python],
который Вы скачали (или создали имитированный upstream- выпуск в разделе xref:preparing-software-for-packaging[Подготовка программного обеспечения]) и разместили его исходный код в ``~/rpmbuild/SOURCES/``. Давайте продолжим и откроем файл  ``~/rpmbuild/SPECS/pello.spec``, и начнём заполнять некоторые поля.

Прежде чем мы начнем идти по этому пути, нам нужно рассмотреть кое-что несколько уникальное в интерпретируемом программном обеспечении с последующей компиляцией в байт-код. Поскольку мы будем использовать компиляцию в байт-код,
ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[shebang]]
ifdef::rhel[shebang]
больше не применим, поскольку результирующий файл не будет содержать эту запись. Общепринятой практикой является либо использование сценария оболочки без компиляции в байт-код, который будет вызывать исполняемый файл, либо наличие небольшого фрагмента кода 
https://www.python.org/[Python] , который не скомпилирован в байт-код, в качестве “точки входа” в выполнение программы. Это может показаться глупым для нашего небольшого примера, но для больших программных проектов со многими тысячами строк кода увеличение производительности при предварительной компиляции в байт-код является значительным.

NOTE: Создание скрипта для вызова байт-скомпилированного кода или наличие небайт-скомпилированной точки входа в программное обеспечение - это то, к чему разработчики upstream программного обеспечения чаще всего обращаются перед выпуском своего программного обеспечения в мир, однако это не всегда так, и это упражнение призвано помочь решить, что делать в таких ситуациях. Для получения дополнительной информации о том, как обычно выпускается и распространяется код
https://www.python.org/[Python], пожалуйста, обратитесь к следующей документации: https://docs.python.org/2/library/distribution.html[Упаковка и распространение программного обеспечения].

Мы создадим небольшой сценарий оболочки для вызова нашего байт-скомпилированного кода, который станет точкой входа в наше программное обеспечение. Мы сделаем это как часть самого нашего файла спецификации, чтобы продемонстрировать, как вы можете создавать сценарии действий внутри SPEC файла. Мы рассмотрим эти особенности позже в разделе ``%install``.

Давайте продолжим и откроем файл  ``~/rpmbuild/SPECS/pello.spec``  и начнем заполнять некоторые поля.

Ниже приведен шаблон вывода, который мы получили из``rpmdev-newspec``.

[source,specfile]
----
Name:           pello
Version:
Release:        1%{?dist}
Summary:

License:
URL:
Source0:

BuildRequires:
Requires:

%description

%prep
%setup -q

%build
%configure
make %{?_smp_mflags}

%install
rm -rf $RPM_BUILD_ROOT
%make_install

%files
%doc

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org>
-

----

Как и в первом примере, давайте начнем с первого набора директив, которые ``rpmdev-newspec``сгруппировал в верхней части файла: ``Name``,
``Version``, ``Release``, ``Summary``. Поле ``Name`` уже заполнено, так как мы передали его в командной строке при использовании команды ``rpmdev-newspec``.

Давайте установим  ``Version`` соответствующую версии “upstream” релиза исходного кода
__pello__ , которая, как мы видим, равна ``0.1.1``, как указано в примире кода, который мы загрузили (или создали в разделе
xref:preparing-software-for-packaging[Подготовка программного обеспечения] section).

В поле ``Release`` уже установлено значение ``1%{?dist}`` которое изначально равно ``1``, и должно увеличиваться каждый раз, когда пакет обнавляется по какой-либо причине, например, включает новый патч для устранения проблемы, но не имеет новой версии upstream-выпуска. Когда происходит новый upstream-выпуск (например, была выпущена версия pello ``0.1.2``) тогда ``Release`` должен быть сброшен до значения ``1``. _disttag_``%{?dist}`` выглядит знакоммо по описанию макросов из xref:rpm-macros[] в предыдущем разделе.

Поле ``Summary`` должно представлять собой краткое, в одну строку, объяснение того, что представляет собой это программное обеспечение.

После Ваших изменений первый раздел SPEC файла примет следующий вид:

[source,specfile]
----
Name:           pello
Version:        0.1.1
Release:        1%{?dist}
Summary:        Hello World example implemented in Python

----

Теперь давайте перейдем ко второму набору директив, которые ``rpmdev-newspec`` сгруппировал вместе в нашем SPEC файле: ``License``, ``URL``, ``Source0``.

ifdef::community[]
Поле ``License`` - это 
https://en.wikipedia.org/wiki/Software_license[Лицензия на программное обеспечение] 
, связанная с исходным кодом из upstream выпуска.  Точный формат обозначения лицензии в вашем файле  SPEC будет варьироваться в зависимости от того, каким конкретным рекомендациям по дистрибутиву
https://en.wikipedia.org/wiki/Linux[Linux], использующему RPM, Вы следуете. Мы будем использовать стандарты обозначения из
https://fedoraproject.org/wiki/Licensing:Main[Fedora Руководство по лицензированию], поэтому это поле будет содержать лицензию ``GPLv3+``
endif::community[]

ifdef::rhel[]
Поле ``License`` - это 
https://en.wikipedia.org/wiki/Software_license[Лицензия на программное обеспечение]
, связанная с исходным кодом из upstream выпуска.  Точный формат обозначения лицензии в вашем файле  SPEC будет варьироваться в зависимости от того, каким конкретным рекомендациям по дистрибутиву
https://en.wikipedia.org/wiki/Linux[Linux], использующему RPM, Вы следуете.
endif::rhel[]


Поле ``URL`` - это веб-сайт upstream программного обеспечения. Это не ссылка на скачивание исходного кода, а фактический веб-сайт проекта, продукта или компании, где кто-то может найти больше информации о конкретной части программного обеспечения. Поскольку это просто пример, мы будем использовать адрес ``https://example.com/pello``. Однако, мы применим макрос RPM  ``%{name}`` для корректности оформления.

Поле ``Source0`` - это место, откуда должен быть загружен upstream исходный код программного обеспечения. Этот URL-адрес должен содержать прямую ссылку на конкретную версию выпуска исходного кода, которую мы упаковываем. Еще раз, поскольку это пример, мы будем использовать ссылку на следующий архив:
``https://example.com/pello/releases/pello-0.1.1.tar.gz``.

Мы должны отметить, что в этом примере URL-адреса есть жёстко закодированные значения, которые можно изменить в будущем, и потенциально они даже могут измениться, например, версия выпуска ``0.1.1``. Мы можем упростить это, если потребуется обновить только одно поле в SPEC файле и разрешить его повторное использование. 
Мы будем использовать макросы
``https://example.com/%{name}/releases/%{name}-%{version}.tar.gz`` вместо ссылок из примеров раннее.

После ваших изменений верхняя часть Вашего SPEC файла должна выглядеть следующим образом:

[source,specfile]
----
Name:           pello
Version:        0.1.1
Release:        1%{?dist}
Summary:        Hello World example implemented in Python

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

----

У нас есть секции ``BuildRequires`` и ``Requires``, каждая из которых определяет что-то, что требуется для пакета. Однако , ``BuildRequires`` должен сообщать
``rpmbuild`` о том, что необходимо Вашему пакету во время **сборки**, а``Requires`` - это то, что необходимо Вашему пакету во время **установки**.

В этом примере нам понадобится пакет ``python`` для выполнения процесса сборки с компиляцией в байт-код.  Этот пакет понадобится во время выполнения скомпилированного байт-кода, поэтому нам необходимо определить ``python`` как требуемый пакет в директиве ``Requires``. Нам также понадобится пакет ``bash`` для выполнения небольшого сценария точки входа, который мы будем использовать здесь.

 Поскольку эта программа написана на интерпритируемом языке программирования без изначально скомпилированных расширений, нужно добавить секцию ``BuildArch``. В ней задано значение noarch, чтобы сообщить RPM, что этот пакет не нужно привязывать к архитектуре процессора, на которой он построен.

После Ваших изменений верхняя часть Вашего SPEC файла должна выглядеть следующим образом:

[source,specfile]
----
Name:           pello
Version:        0.1.1
Release:        1%{?dist}
Summary:        Hello World example implemented in Python

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

BuildRequires:  python
Requires:       python
Requires:       bash

BuildArch:      noarch

----

Следующие директивы можно рассматривать как “заголовки разделов”, поскольку они являются директивами, которые могут определять многостроковые, скриптовые или состоящие из нескольких инструкций задачи. Мы пройдемся по ним одна за другой, как и по предыдущим пунктам.

Секция ``%description`` - это более длинное и полное описание программного обеспечения, чем ``Summary``, содержащее один или несколько абзацев. В нашем примере мы будем использовать только краткое описание. Эта секция не будет содержать глубокое описание, но при желании раздел может быть целым абзацем или более.

Секция ``%prep`` - это место, где мы __подготавливаем__ нашу среду сборки или рабочее пространство для сборки. Чаще всего здесь происходит расширение сжатых архивов исходного кода, применение исправлений и, возможно, анализ информации, предоставленной в исходном коде, которая необходима в следующей части SPEC файла. В этом разделе мы просто будем использовать предоставленный макрос ``%setup -q``.

Секция ``%build``- это раздел, где мы рассказываем системе, как на самом деле собирать программное обеспечение, которое мы упаковываем. Здесь мы выполним компиляцию нашего программного обеспечения в байт-код. Для тех, кто читал раздел xref:preparing-software-for-packaging[Подготовка программного обеспечения], эта часть примера должна показаться знакомой.

Секция ``%build`` нашего SPEC файла должна выглядеть следующим образом:

[source,specfile]
----
%build

python -m compileall pello.py

----

Секция ``%install`` - это раздел, отвечающий за инструктирование ``rpmbuild``, устанавливающее наше ранее созданное программное обеспечение в ``BUILDROOT``, который фактически является базовым каталогом
ifdef::community[https://en.wikipedia.org/wiki/Chroot[chroot]]
ifdef::rhel[chroot]
, в котором ничего нет, и нам нужно будет создать любые пути или иерархии каталогов, которые нам понадобятся, чтобы установить наше программное обеспечение в определенных местах. Однако наши макросы RPM помогают нам выполнить эту задачу без необходимости жестко кодировать пути.

Ранее мы обсуждали, что, поскольку мы потеряем контекст файла со строкой
ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[shebang]]
ifdef::rhel[shebang]
в нём при компиляции в байт-код, нам нужно будет создать простой сценарий-оболочку для выполнения этой задачи.  Есть много вариантов того, как это сделать, включая, но не ограничиваясь этим, создание отдельного скрипта и использование его в качестве отдельной директивы ``SourceX``, а также вариант, который мы собираемся показать в этом примере, который заключается в сборке файла в строке в SPEC файле. Причина, по которой мы показываем примерный вариант, заключается в том, чтобы просто продемонстрировать, что сам файл спецификации доступен для сценариев. Мы собираемся создать небольшой “сценарий-оболочку”, который будет выполнять скомпилированный байт-код
https://www.python.org/[Python], используя
ifdef::community[https://en.wikipedia.org/wiki/Here_document[here document]]
ifdef::rhel["here" document]
. Нам также нужно будет установить 
скомпилированный байт-код в каталог библиотеки в системе, чтобы к нему можно было получить доступ.

NOTE: Ниже Вы заметите, что мы жестко кодируем путь к библиотеке. Существуют различные методы, позволяющие избежать необходимости делать это, многие из которых рассматриваются в
<<дополнительных разделах>>, в разделе xref:more-on-macros[Подрбнее о макросах], и специфичны для языка программирования, на котором было написано упаковываемое программное обеспечение. В этом примере мы жестко закодировали путь для простоты, чтобы не охватывать слишком много тем одновременно.

Секция ``%install`` после Ваших изменений должна выглядеть следующим образом:

[source,specfile]
----
%install

mkdir -p %{buildroot}/%{_bindir}
mkdir -p %{buildroot}/usr/lib/%{name}

cat > %{buildroot}/%{_bindir}/%{name} <<-EOF
#!/bin/bash
/usr/bin/python /usr/lib/%{name}/%{name}.pyc
EOF

chmod 0755 %{buildroot}/%{_bindir}/%{name}

install -m 0644 %{name}.py* %{buildroot}/usr/lib/%{name}/

----

Секция ``%files`` - это место, где мы предоставляем список файлов, которые предоставляет этот RPM и где они должны находиться в системе, на которую установлен RPM. Обратите внимание, что это относится не к ``%{buildroot}``, а к полному пути к файлам, поскольку ожидается, что они будут существовать в конечной системе после установки. Таким образом, список устанавливаемого файла ``pello``  будет: ``%{_bindir}/pello``.  Нам также нужно будет предоставить список ``%dir``, чтобы определить, что этот пакет “владеет” каталогом библиотеки, который мы создали, а также всеми файлами, которые мы разместили в нём.

Кроме того, в этом разделе Вам иногда понадобится встроенный макрос для предоставления контекста файла. Это может быть полезно для системных администраторов и конечных пользователей, которые могут захотеть запросить систему о конечном пакете с помощью ``rpm``. Встроенный макрос, который мы будем использовать здесь, - это ``%license``, который сообщит ``rpmbuild``, что это файл лицензии на программное обеспечение в метаданных манифеста файла пакета.

Секция ``%files`` после Ваших изменений должен выглядеть следующим образом:
[source,specfile]
----
%files
%license LICENSE
%dir /usr/lib/%{name}/
%{_bindir}/%{name}
/usr/lib/%{name}/%{name}.py*

----

Последняя секция, ``%changelog``, представляет собой список записей с отметками о дате, которые соотносятся с конкретной версией-выпуском пакета. Это не журнал изменений в программном обеспечении от выпуска к выпуску, а конкретно изменения в упаковке. Например, если программное обеспечение в пакете нуждалось в исправлении или было необходимо внести изменения в процедуру сборки, указанную в секции``%build``, эта информация будет размещена здесь. Каждая запись изменения может содержать несколько элементов, и каждый элемент должен начинаться с новой строки и символа ``-``.
Ниже приведен наш пример записи:

[source,specfile]
----
%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1.1-1
- First pello package
- Example second item in the changelog for version-release 0.1.1-1

----

Обратите внимание на приведенный выше формат: отметка даты будет начинаться с символа ``*``, за которым следует календарный день недели, месяц, день месяца, год, затем контактная информация для упаковщика RPM. Оттуда у нас есть символ``-`` перед выпуском версии, что является часто используемым, но не строго регламентированным. Затем, наконец, Версия-Релиз.

Вот и все! Мы написали целый файл спецификаций для **pello**! В следующем разделе мы расскажем, как создать RPM!

Полный файл спецификации теперь должен выглядеть следующим образом:

[source,specfile]
----
Name:           pello
Version:        0.1.1
Release:        1%{?dist}
Summary:        Hello World example implemented in python

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

BuildRequires:  python
Requires:       python
Requires:       bash

BuildArch:      noarch

%description
The long-tail description for our Hello World Example implemented in
Python.

%prep
%setup -q

%build

python -m compileall %{name}.py

%install

mkdir -p %{buildroot}/%{_bindir}
mkdir -p %{buildroot}/usr/lib/%{name}

cat > %{buildroot}/%{_bindir}/%{name} <<-EOF
#!/bin/bash
/usr/bin/python /usr/lib/%{name}/%{name}.pyc
EOF

chmod 0755 %{buildroot}/%{_bindir}/%{name}

install -m 0644 %{name}.py* %{buildroot}/usr/lib/%{name}/

%files
%license LICENSE
%dir /usr/lib/%{name}/
%{_bindir}/%{name}
/usr/lib/%{name}/%{name}.py*

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1.1-1
  - First pello package

----

[[cello-working-with-spec-files]]
==== cello

Наш третий SPEC файл будет для нашего примера на языке
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
, для которого мы ранее создали имитированную версию upstream (или вы скачали) и разместили его исходный код в ``~/rpmbuild/SOURCES/``.

Давайте откроем файл ``~/rpmbuild/SPECS/cello.spec`` и начнём заполнять некоторые поля. 

Ниже приведен шаблон вывода, который мы получили от  ``rpmdev-newspec``.

[source,specfile]
----
Name:           cello
Version:
Release:        1%{?dist}
Summary:

License:
URL:
Source0:

BuildRequires:
Requires:

%description

%prep
%setup -q

%build
%configure
make %{?_smp_mflags}

%install
rm -rf $RPM_BUILD_ROOT
%make_install

%files
%doc

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org>
-

----
Как и в предыдущих примерах, давайте начнем с первого набора директив, которые ``rpmdev-newspec`` сгруппировал в верхней части файла: 
``Name``, ``Version``, ``Release``, ``Summary``. The ``Name`` уже указано, потому что мы предоставили эту информацию в командной строке для ``rpmdev-newspec``.

Давайте установим в поле ``Version`` значение, соответствующее “upstream” версии исходного кода
__cello__, которая, как мы видим, равна ``1.0``, как указано в примере кода, который мы загрузили (или создали в секции xref:preparing-software-for-packaging[Подготовка программного обеспечения]).

В ``Release`` уже установлено значение ``1%{?dist}``  числовое значение, которое изначально равно ``1``, должно увеличиваться каждый раз, когда пакет обновляется по какой-либо причине, например, включает новый патч для устранения проблемы, но не имеет новой версии upstream выпуска. Когда происходит новый upstream выпуск  (например, была выпущена версия cello ``2.0``), тогда значение ``Release`` должно быть сброшено до``1``.  _disttag_``%{?dist}`` выглядит знакоммо по описанию макросов из xref:rpm-macros[] в предыдущем разделе.

``Summary`` должно представлять собой краткое, в одну строку, объяснение того, что представляет собой это программное обеспечение.

После ваших изменений первый раздел SPEC файла должен выглядеть следующим образом:

[source,specfile]
----
Name:           cello
Version:        1.0
Release:        1%{?dist}
Summary:        Hello World example implemented in C
----

Теперь давайте перейдем ко второму набору директив, которые ``rpmdev-newspec`` сгруппировал вместе в нашем SPEC файле: ``License``, ``URL``, ``Source0``. Однако, мы добавим одну директиву в эту группу, поскольку она тесно связана с ``Source0`` , и это наш  ``Patch0`` в котором будет указан первый патч, который нам нужен для нашего программного обеспечения.


Поле ``License`` - это 
https://en.wikipedia.org/wiki/Software_license[Лицензия на программное обеспечение], связанная с исходным кодом из upstream выпуска.  Точный формат обозначения лицензии в вашем SPEC файле будет варьироваться в зависимости от того, каким конкретным рекомендациям по дистрибутиву
https://en.wikipedia.org/wiki/Linux[Linux], использующим RPM, Вы следуете. Мы будем использовать стандарты обозначения из
https://fedoraproject.org/wiki/Licensing:Main[Fedora. Руководство по лицензированию], поэтому это поле будет содержать лицензию ``GPLv3+``

Поле ``URL`` - это веб-сайт upstream программного обеспечения. Это не ссылка на скачивание исходного кода, а фактический веб-сайт проекта, продукта или компании, где кто-то может найти больше информации об этой конкретной части программного обеспечения. Поскольку это просто пример, мы будем использовать адрес. ``https://example.com/сello``. Однако, мы применим макрос RPM  ``%{name}`` для корректности оформления.

Поле ``Source0`` - это место, откуда должен быть загружен upstream исходный код программного обеспечения. Этот URL-адрес должен содержать прямую ссылку на конкретную версию выпуска исходного кода, которую мы упаковываем. Еще раз, поскольку это пример, мы будем использовать ссылку на следующий архив:
``https://example.com/cello/releases/cello-1.0.tar.gz``

Мы должны отметить, что в этом примере URL-адреса есть жестко закодированные значения, которые можно изменить в будущем и потенциально они даже могут измениться, например, версия выпуска ``1.0``. Мы можем упростить это, если потребуется обновить только одно поле в SPEC файле и разрешить его повторное использование. 
Мы будем использовать макросы
``https://example.com/%{name}/releases/%{name}-%{version}.tar.gz``, вместо ссылок из примеров раннее.

Следующий пункт - предоставить список для файла ``.patch`` который мы создали ранее, чтобы мы могли применить его к коду позже в секции``%prep``. Нам понадобится список  ``Patch0: cello-output-first-patch.patch``.

После Ваших изменений верхняя часть SPEC файла должна выглядеть следующим образом:

[source,specfile]
----
Name:           cello
Version:        1.0
Release:        1%{?dist}
Summary:        Hello World example implemented in C

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

Patch0:         cello-output-first-patch.patch

----

У нас есть секции ``BuildRequires`` и ``Requires``, каждая из которых определяет что-то, что требуется для пакета. Однако, ``BuildRequires`` должен сообщать
``rpmbuild``, что необходимо Вашему пакету во время **сборки**, а``Requires`` - это то, что необходимо пакету во время **установки**.

В этом примере нам понадобятся пакеты ``gcc`` и ``make`` для выполнения процесса сборки и компиляции. Требования времени выполнения, к счастью, обрабатываются `rpmbuild`, потому что эта программа не требует ничего за пределами основных стандартных библиотек
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
, и поэтому нам не нужно будет определять что-либо вручную в качестве ``Requires`` , и мы можем опустить эту директиву.

После Ваших изменений верхняя часть SPEC Вашего файла должна выглядеть следующим образом:

[source,specfile]
----
Name:           cello
Version:        0.1
Release:        1%{?dist}
Summary:        Hello World example implemented in C

License:        GPLv3+
URL:            https://example.com/%{name}
Source0:        https://example.com/%{name}/release/%{name}-%{version}.tar.gz

BuildRequires:  gcc
BuildRequires:  make

----

Следующие директивы являются заголовками секций, поскольку они определяют многостроковые, скриптовые или состоящие из нескольких инструкций задачи. Мы пройдемся по ним один за другим, как и по предыдущим пунктам.

Секция ``%description`` - это более длинное и полное описание программного обеспечения, чем ``Summary``, содержащее один или несколько абзацев. В нашем примере мы будем использовать только краткое описание. В нашем примере это секция не будет содержать глубокое описание, но при желании этот раздел может быть целым абзацем и более.

Секция ``%prep`` - это место, где мы __подготавливаем__ нашу среду сборки или рабочее пространство для сборки. Чаще всего здесь происходит расширение сжатых архивов исходного кода, применение исправлений и, возможно, анализ информации, предоставленной в исходном коде, которая необходима в следующей части  SPEC файла. В этом разделе мы просто будем использовать предоставленный макрос ``%setup -q``.

Секция ``%build`` это то, где мы рассказываем системе, как на самом деле собирать программное обеспечение, которое мы упаковываем. Поскольку мы написали простой  ``Makefile`` для нашей реализации на
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
, мы можем просто использовать команду http://www.gnu.org/software/make/[GNU make]: ``rpmdev-newspec``. Однако нам нужно удалить вызов, ``%configure``, поскольку мы не предоставили
ifdef::community[https://en.wikipedia.org/wiki/Configure_script[configure script]]
ifdef::rhel[configure script]
. Секция ``%build`` нашего SPEC файла должна выглядеть следующим образом. 

[source,specfile]
----
%build
make %{?_smp_mflags}

----

Секция ``%install`` - это то, где мы инструктируем ``rpmbuild`` как установить наше программное обеспечение в ``BUILDROOT``, который фактически является базовым каталогом
ifdef::community[https://en.wikipedia.org/wiki/Chroot[chroot]]
ifdef::rhel[chroot]
, в котором ничего нет, и нам нужно будет создать любые пути или иерархии каталогов, которые нам понадобятся, чтобы установить наше программное обеспечение. Однако наши макросы RPM помогают нам выполнить эту задачу без необходимости жестко кодировать пути.

Еще раз, поскольку у нас есть простой  ``Makefile`` , шаг установки можно легко выполнить, оставив на месте макрос ``%make_install`` , который снова был предоставлен нам командой ``rpmdev-newspec``.

Секция ``%install`` после Ваших изменений должна принять следующий вид:

[source,specfile]
----
%install
%make_install

----

Секция ``%files`` - это место, где мы предоставляем список файлов, которые предоставляет этот RPM, и где они должны находиться в системе. Обратите внимание, что это относится не к ``%{buildroot}``, а к полному пути к файлам, поскольку ожидается, что они будут существовать в конечной системе после установки. Таким образом, путь устанавливаемого файла ``cello`` будет: ``%{_bindir}/cello``.

Кроме того, в этом разделе Вам иногда понадобится встроенный макрос для предоставления контекста для файла. Это может быть полезно для системных администраторов и конечных пользователей, которые могут захотеть запросить систему с помощью ``rpm`` о конечном пакете. Встроенный макрос, который мы будем использовать здесь, это ``%license``, который сообщит ``rpmbuild``, что это файл лицензии на программное обеспечение в метаданных.

Секция ``%files`` после Ваших изменений должна выглядеть следующим образом:

[source,specfile]
----
%files
%license LICENSE
%{_bindir}/%{name}

----

Последняя секция, ``%changelog``, представляет собой список записей с отметками о дате, которые соотносятся с конкретной версией-выпуском пакета. Это не журнал изменений в программном обеспечении от выпуска к выпуску, а конкретно изменения в упаковке. Например, если программное обеспечение в пакете нуждалось в исправлении или было необходимо внести изменения в процедуру сборки, указанную в секции``%build``, эта информация будет размещена здесь. Каждая запись изменения может содержать несколько элементов, и каждый элемент должен начинаться с новой строки и символа ``-``.
Ниже приведен наш пример записи:

[source,specfile]
----
%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 0.1-1
- First cello package

----

Обратите внимание на приведенный выше формат, отметка даты будет начинаться с символа ``*``, за которым следует календарный день недели, месяц, день месяца, год, затем контактная информация для упаковщика RPM. Оттуда у нас есть символ``-`` перед выпуском версии, что является часто используемым, но не строго регламентированным. Затем, наконец, Версия-Релиз.

Вот и все! Мы написали целый файл спецификаций для **cello**! 

Полный файл спецификации теперь должен выглядеть следующим образом:

[source,specfile]
----
Name:           cello
Version:        1.0
Release:        1%{?dist}
Summary:        Hello World example implemented in C

License:        GPLv3+
URL:            https://www.example.com/%{name}
Source0:        https://www.example.com/%{name}/releases/%{name}-%{version}.tar.gz

Patch0:         cello-output-first-patch.patch

BuildRequires:  gcc
BuildRequires:  make

%description
The long-tail description for our Hello World Example implemented in
C.

%prep
%setup -q

%patch0

%build
make %{?_smp_mflags}

%install
%make_install

%files
%license LICENSE
%{_bindir}/%{name}

%changelog
* Tue May 31 2016 Adam Miller <maxamillion@fedoraproject.org> - 1.0-1
- First cello package

----

Пакет ``rpmdevtools`` предоставляет набор шаблонов файлов спецификаций для нескольких популярных языков в каталоге``/etc/rpmdevtools/``.

////
////
[[building-rpms]]
== Сборка RPMS

RPMs собираются с помощью команды  ``rpmbuild``. Различные сценарии и желаемые результаты требуют различных комбинаций аргументов для ``rpmbuild``. В этом разделе описываются два основных сценария:

. сборка исходного RPM
. сборка бинарного RPM

Команда ``rpmbuild`` ожидает определенную структуру каталогов и файлов.  Это та же структура, что и в утилите ``rpmdev-setuptree``. Предыдущие инструкции также подтвердили требуемую структуру.

[[source-rpms]]
=== Исходный RPMs

Зачем создавать исходный RPM (SRPM)?

. Чтобы сохранить точный источник определенного Name-Version-Release RPM, который был развернут в среде.  Это включает в себя точный SPEC файл, исходный код и все соответствующие исправления. Это полезно для просмотра истории и для отладки.
ifdef::community[]
. Чтобы иметь возможность создавать бинарный RPM на другой аппаратной платформе или
https://en.wikipedia.org/wiki/Microarchitecture[архитектуре].
endif::community[]

ifdef::rhel[]
. Чтобы иметь возможность создавать бинарный RPM на другой аппаратной платформе или архитектуре.
endif::rhel[]

[[create-source-rpms]]
==== Для сборки SRPM:

[source,bash]
----
$ rpmbuild -bs _SPECFILE_

----

Замените _SPECFILE_ именем SPEC файла. Параметр  ``-bs`` "исходный код сборки".

Здесь мы собираем SRPMs для ``bello``, ``pello`` и ``cello``:

[source,bash]
----
$ cd ~/rpmbuild/SPECS/

$ rpmbuild -bs bello.spec
Wrote: /home/admiller/rpmbuild/SRPMS/bello-0.1-1.el7.src.rpm

$ rpmbuild -bs pello.spec
Wrote: /home/admiller/rpmbuild/SRPMS/pello-0.1.1-1.el7.src.rpm

$ rpmbuild -bs cello.spec
Wrote: /home/admiller/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm

----

Обратите внимание, что SRPMS были помещены в каталог  ``rpmbuild/SRPMS``, который является частью структуры, ожидаемой ``rpmbuild``.

Это все, что нужно для сборки SRPM.

[[binary-rpms]]
=== Бинарный RPMS

Существует два метода сборки бинарных RPMs:

. Восстановление его из SRPM с использованием комманды``rpmbuild --rebuild``.
. Собираем его из файла спецификации с помощью команды ``rpmbuild -bb``. Опция  ``-bb`` означает "собрать бинарный файл" (``build binary``).

[[rebuild]]
==== Восстановление из исходного RPM

Чтобы перестроить ``bello``, ``pello`` и ``cello`` из исходных RPM (SRPMs), запустите:

[source,bash]
----
$ rpmbuild --rebuild ~/rpmbuild/SRPMS/bello-0.1-1.el7.src.rpm
[output truncated]

$ rpmbuild --rebuild ~/rpmbuild/SRPMS/pello-0.1.1-1.el7.src.rpm
[output truncated]

$ rpmbuild --rebuild ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm
[output truncated]

----

Теперь Вы собрали RPM. Несколько заметок:

* Выходные данные, генерируемые при сборке бинарного RPM, являются подробными, что полезно для отладки. Выходные данные различаются для разных примеров и соответствуют их SPEC файлам.
*  Конечные бинарные RPM находятся в   ``~/rpmbuild/RPMS/YOURARCH``, где ``YOURARCH`` - это Ваша
ifdef::community[https://en.wikipedia.org/wiki/Microarchitecture[архитектура]]
ifdef::rhel[архитектура]
, или в
``~/rpmbuild/RPMS/noarch/``, если пакет не зависит от архитектуры.
* Вызов ``rpmbuild --rebuild`` включает в себя:
+
--
. Установку содержимого RPM - файла спецификации и исходного кода - в каталог ``~/rpmbuild/``.
. Сборка с использованием установленного содержимого.
. Удаление файла спецификации и исходного кода.
--
+
Вы можете сохранить файл спецификации и исходный код после сборки. Для этого у Вас есть два варианта:
+
--
* При сборке используйте опцию  ``--recompile`` вместо ``--rebuild``.
* Установите SRPMS с помощью следующих команд:
--
+
[source,bash]
----
$ rpm -Uvh ~/rpmbuild/SRPMS/bello-0.1-1.el7.src.rpm
Updating / installing...
   1:bello-0.1-1.el7                  ################################# [100%]

$ rpm -Uvh ~/rpmbuild/SRPMS/pello-0.1.1-1.el7.src.rpm
Updating / installing...
   1:pello-0.1.1-1.el7                ################################# [100%]

$ rpm -Uvh ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm
Updating / installing...
   1:cello-1.0-1.el7                  ################################# [100%]

----
+
В этом руководстве выполните приведенные выше команды ``rpm -Uvh`` чтобы продолжить взаимодействие с файлами спецификаций и исходными кодами.

[[build-binary]]
==== Создание бинарного файла из SPEC файла

Чтобы собрать ``bello``, ``pello``, и ``cello`` из их SPEC файлов, запустите:

[source,bash]
----
$ rpmbuild -bb ~/rpmbuild/SPECS/bello.spec

$ rpmbuild -bb ~/rpmbuild/SPECS/pello.spec

$ rpmbuild -bb ~/rpmbuild/SPECS/cello.spec

----

Теперь Вы собрали RPM из SPEC файлов.

Большая часть информации, содержащейся в разделе xref:rebuild[] применима здесь.
//// 
////
[[checking-rpms-for-sanity]]
== Проверка RPMs на корректность

После создания упаковки хорошо бы проверить её качество. Качество пакета, а не программного обеспечения, поставляемого в нём. Основным инструментом для этого является
https://github.com/rpm-software-management/rpmlint[rpmlint]. Это улучшает редактируемость RPM и обеспечивает проверку работоспособности и ошибок путем выполнения статического анализа  RPM. Эта утилита может проверять бинарные RPM, исходные RPM (SRPMs) и spec файлы, поэтому она полезна на всех этапах упаковки, как показано в следующих примерах.

Обратите внимание, что ``rpmlint`` имеет очень строгие правила, и иногда допустимо и необходимо пропустить некоторые из его ошибок и предупреждений, как показано в следующих примерах.

NOTE: В примерах мы запускаем ``rpmlint`` без каких-либо опций, что приводит к невербальному выводу. Для получения подробных объяснений каждой ошибки или предупреждения вместо этого запустите 
``rpmlint -i`` instead.

[[checking-bello-spec-file]]
=== Проверка SPEC файла bello

Это результат выполнения  ``rpmlint`` в SPEC файле ``bello``:

[source,bash]
----
$ rpmlint bello.spec
bello.spec: W: invalid-url Source0: https://www.example.com/bello/releases/bello-0.1.tar.gz HTTP Error 404: Not Found
0 packages and 1 specfiles checked; 0 errors, 1 warnings.

----

Наблюдения:

* Для ``bello.spec`` есть только одно предупреждение. В нем говорится, что URL-адрес, указанный в директиве
``Source0`` недоступен. Это ожидаемо, поскольку указанный ``example.com`` URL-адрес не существует. Предполагая, что мы ожидаем, что этот URL-адрес будет работать в будущем, мы можем проигнорировать это предупреждение

Это результат выполнения ``rpmlint`` на SRPM для ``bello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/SRPMS/bello-0.1-1.el7.src.rpm
bello.src: W: invalid-url URL: https://www.example.com/bello HTTP Error 404: Not Found
bello.src: W: invalid-url Source0: https://www.example.com/bello/releases/bello-0.1.tar.gz HTTP Error 404: Not Found
1 packages and 0 specfiles checked; 0 errors, 2 warnings.

----

Наблюдения:

* Для ``bello`` SRPM появилось новое предупреждение, в котором говорится, что URL-адрес, указанный в директиве URL, недоступен. Предполагая, что ссылка будет работать в будущем, мы можем проигнорировать это предупреждение.

[[checking-bello-binary-rpm]]
=== Проверка бинарного RPM bello

При проверке бинарных RPMs, ``rpmlint`` проверяет дополнительные параметры, в том числе:

. документацию
ifdef::community[. https://en.wikipedia.org/wiki/Man_page[страницы руководства]]
ifdef::rhel[. страницы руководства]
ifdef::community[. корректность  https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[Иерархии файловой системы]]
ifdef::rhel[. корректность Иерархии Файловой Системы]

Это результат выполнения``rpmlint`` на бинарном RPM для ``bello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/RPMS/noarch/bello-0.1-1.el7.noarch.rpm
bello.noarch: W: invalid-url URL: https://www.example.com/bello HTTP Error 404: Not Found
bello.noarch: W: no-documentation
bello.noarch: W: no-manual-page-for-binary bello
1 packages and 0 specfiles checked; 0 errors, 3 warnings.

----

Наблюдения:

* ``no-documentation`` и``no-manual-page-for-binary`` оворят о том, что в RPM нет документации или страниц руководства, потому что мы их не предоставили.

Помимо вышеприведенных предупреждений, наш RPM проходит проверку ``rpmlint``.

[[checking-pello-spec-file]]
=== Проверка SPEC файла pello 

Это результат выполнения ``rpmlint`` на SPEC файле ``pello``:

[source,bash]
----
$ rpmlint pello.spec
pello.spec:30: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}
pello.spec:34: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.pyc
pello.spec:39: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}/
pello.spec:43: E: hardcoded-library-path in /usr/lib/%{name}/
pello.spec:45: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.py*
pello.spec: W: invalid-url Source0: https://www.example.com/pello/releases/pello-0.1.1.tar.gz HTTP Error 404: Not Found
0 packages and 1 specfiles checked; 5 errors, 1 warnings.

----

Наблюдения:

* Предупреждение ``invalid-url Source0`` wговорит о том, что URL-адрес, указанный в директиве Source0 - недоступен. Это ожидаемо, поскольку указанный example.com URL-адрес не существует. Предполагая, что мы ожидаем, что этот URL-адрес будет работать в будущем, мы можем проигнорировать это предупреждение.
* Ошибок много, потому что мы намеренно написали этот файл спецификации, чтобы он был простым и показывал, о каких ошибках может сообщать ``rpmlint``.
* Ошибки ``hardcoded-library-path`` предполагают использование макроса  ``%{_libdir}`` вместо жесткого кодирования пути к библиотеке. Ради этого примера мы игнорируем эти ошибки, но для пакетов, запущенных в производство, Вам нужна веская причина для игнорирования этой ошибки.

Это результат выполнения ``rpmlint`` на SRPM  ``pello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/SRPMS/pello-0.1.1-1.el7.src.rpm
pello.src: W: invalid-url URL: https://www.example.com/pello HTTP Error 404: Not Found
pello.src:30: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}
pello.src:34: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.pyc
pello.src:39: E: hardcoded-library-path in %{buildroot}/usr/lib/%{name}/
pello.src:43: E: hardcoded-library-path in /usr/lib/%{name}/
pello.src:45: E: hardcoded-library-path in /usr/lib/%{name}/%{name}.py*
pello.src: W: invalid-url Source0: https://www.example.com/pello/releases/pello-0.1.1.tar.gz HTTP Error 404: Not Found
1 packages and 0 specfiles checked; 5 errors, 2 warnings.

----

Наблюдения:

* Новая ошибка``invalid-url URL`` здесь связана с директивой ``URL``, которая недоступна.  Предполагая, что мы ожидаем, что URL-адрес станет действительным в будущем, мы можем игнорировать эту ошибку.

[[checking-pello-binary-rpm]]
=== Проверка бинарного RPM pello 

При проверке бинарного RPMs, ``rpmlint`` проверяет дополнительные параметры, в том числе:


. документацию
ifdef::community[. https://en.wikipedia.org/wiki/Man_page[страницы руководства]]
ifdef::rhel[. страницы руководства]
. последовательное использование
ifdef::community[. корректность  https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[Иерархии файловой системы]]
ifdef::rhel[. корректность Иерархии Файловой Системы]

Это результат выполнения ``rpmlint`` на бинарном RPM для ``pello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/RPMS/noarch/pello-0.1.1-1.el7.noarch.rpm
pello.noarch: W: invalid-url URL: https://www.example.com/pello HTTP Error 404: Not Found
pello.noarch: W: only-non-binary-in-usr-lib
pello.noarch: W: no-documentation
pello.noarch: E: non-executable-script /usr/lib/pello/pello.py 0644L /usr/bin/env
pello.noarch: W: no-manual-page-for-binary pello
1 packages and 0 specfiles checked; 1 errors, 4 warnings.

----

Наблюдения:

* Предупреждения  ``no-documentation`` и ``no-manual-page-for-binary`` говорят о том, что в RPM нет документации или страниц руководства, потому что мы их не предоставили.
* Предупреждение  ``only-non-binary-in-usr-lib`` гласит, что Вы предоставили только бинарные артефакты  ``/usr/lib/``. Этот каталог обычно зарезервирован для общих объектных файлов, которые являются бинарными файлами. Следовательно, ``rpmlint`` eожидает, что по крайней мере один или несколько файлов в ``/usr/lib/`` будут бинарными.
+
Это пример проверки ``rpmlint`` на соответствие
ifdef::community[https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[Иерархии Файловой Системы]]
ifdef::rhel[Иерархии Файловой системы ]
.
+
Обычно для обеспечения правильного размещения файлов используются макросы RPM. Ради этого примера мы можем проигнорировать это предупреждение.
* Ошибка ``non-executable-script`` предупреждает о том, что ``/usr/lib/pello/pello.py``
файл не имеет прав на выполнение. Поскольку этот файл содержит
ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[shebang]]
ifdef::rhel[shebang]
, ``rpmlint`` ожидает, что файл будет исполняемым. Для целей примера оставьте этот файл без разрешений на выполнение и проигнорируйте эту ошибку.


Помимо вышеприведенных предупреждений и ошибок, наш RPM проходит проверку ``rpmlint``.

[[checking-cello-spec-file]]
=== Проверка SPEC файла cello 

Это результат выполнения ``rpmlint`` на SPEC файле ``cello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/SPECS/cello.spec
/home/admiller/rpmbuild/SPECS/cello.spec: W: invalid-url Source0: https://www.example.com/cello/releases/cello-1.0.tar.gz HTTP Error 404: Not Found
0 packages and 1 specfiles checked; 0 errors, 1 warnings.

----

Наблюдения:

* Единственное предупреждение для ``cello.spec`` гласит, что URL-адрес, указанный в директиве 
``Source0``, недоступен. Это ожидаемо, поскольку указанный ``example.com`` URL-адрес не существует. Предполагая, что мы ожидаем, что этот URL-адрес будет работать в будущем, мы можем проигнорировать это предупреждение.

Это результат выполнения ``rpmlint`` в файле SRPM для ``cello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/SRPMS/cello-1.0-1.el7.src.rpm
cello.src: W: invalid-url URL: https://www.example.com/cello HTTP Error 404: Not Found
cello.src: W: invalid-url Source0: https://www.example.com/cello/releases/cello-1.0.tar.gz HTTP Error 404: Not Found
1 packages and 0 specfiles checked; 0 errors, 2 warnings.

----

Наблюдения:

* Для ``cello`` SRPM появилось новое предупреждение, в котором говорится, что URL-адрес, указанный в директиве ``URL``, недоступен.  Предполагая, что ссылка будет работать в будущем, мы можем проигнорировать это предупреждение.

[[checking-cello-binary-rpm]]
=== Проверка бинарного RPM cello

При проверке бинарных RPMs, ``rpmlint`` проверяет дополнительные параметры, в том числе:

. документацию
ifdef::community[. https://en.wikipedia.org/wiki/Man_page[страницы руководства]]
ifdef::rhel[. страницы руководства]
ifdef::community[. корректность  https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[Иерархии файловой системы]]
ifdef::rhel[. корректность Иерархии Файловой Системы]
.

Это результат выполнения ``rpmlint`` на бинарном RPM для ``cello``:

[source,bash]
----
$ rpmlint ~/rpmbuild/RPMS/x86_64/cello-1.0-1.el7.x86_64.rpm
cello.x86_64: W: invalid-url URL: https://www.example.com/cello HTTP Error 404: Not Found
cello.x86_64: W: no-documentation
cello.x86_64: W: no-manual-page-for-binary cello
1 packages and 0 specfiles checked; 0 errors, 3 warnings.
----

Наблюдения:

* Предупреждения ``no-documentation`` и ``no-manual-page-for-binary`` говорят о том, что в RPM нет документации или страниц руководства, потому что мы их не предоставили.
////
//Помимо вышеприведенных предупреждений и ошибок, наш RPM проходит проверку ``rpmlint``.

//Наши RPM теперь готовы и проверены с помощью ``rpmlint``. На этом учебное пособие заканчивается. Для получения дополнительной информации о RPM упаковке перейдите к главе
//xref:advanced-topics[Дополнительные материалы].
