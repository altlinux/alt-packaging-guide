[[preparing-software-for-packaging]]
= Подготовка программного обеспечения для упаковки

//Эта глава посвящена исходному коду и созданию программного обеспечения, которые являются необходимой основой для RPM-упаковщика.

[[what-is-source-code]]
== Что такое Исходный код?

**Исходный код ** -- это последовательность инструкций процессора, описываемых при помощи языка программирования.

**Исполняемый код** -- это результат трансляции исходного кода компилятором. Исполняемый код представляет из себя последовательность кодов представленных в двоичной системе счисления.

В этом примере представлена программа выводящая строку ``Hello World`` , написанная на трех языках программирования. Несмотря на идентичную функциональность программ, подход к сборке rpm-пакета для каждой из них отличается. Выбор языков bash, Python и C обусловлен тем, что разбор примеров именно на этих ЯП охватывает три основных варианта использования RPM упаковщиком ПО.

NOTE: Языков программирования существенно больше, но трех выбранных выше достаточно для концептуального обзора.

Программа ``Hello World``, написанная на https://www.gnu.org/software/bash/[bash]:

``bello``

[source,bash]
----
#!/bin/bash

printf "Hello World\n"

----

``Hello World``, написанная на https://www.python.org/[Python]:

``pello.py``

[source,python]
----
#!/usr/bin/env python

print("Hello World")

----

``Hello World``, написанная на
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
:

``cello.c``

[source,c]
----
#include <stdio.h>

int main(void) {
    printf("Hello World\n");
    return 0;
}

----

Результатом выполнения каждой из трех программ является вывод строки ``Hello World`` в
 командной строке.

NOTE: Знание того, как программировать, не обязательно для упаковщика программного обеспечения, но полезно.

[[how-programs-are-made]]
== Как создаются программы

//Существует множество методов, с помощью которых читаемый человеком исходный код становится машинным кодом - инструкциями, которым компьютер следует для фактического выполнения программы. Однако все методы можно свести к этим трем:

//1. Программа изначально скомпилирована.
//2. Программа интерпретируется с помощью необработанной интерпретации.
//3. Программа интерпретируется путем байтовой компиляции.

[[natively-compiled-code]]
=== Изначально скомпилированный код

//**Изначально скомпилированное** программное обеспечение - это программное обеспечение, написанное на языке программирования, которое компилируется в машинный код с результирующим ,бинарным исполняемым файлом. Такое программное обеспечение можно запускать автономно.

//Пакеты RPM, созданные таким образом, зависят от
//ifdef::community[https://ru.wikipedia.org/wiki/Микроархитектура[архитектуры]]
//ifdef::rhel[архитектуры]
//Это означает, что если вы скомпилируете такое программное обеспечение на компьютере, использующем 64-разрядный (x86_64) процессор AMD или Intel, оно не будет выполняться на 32-разрядном (x86) процессоре AMD или Intel. В названии результирующего пакета будет указана архитектура.

[[interpreted-code]]
=== Интерпретируемый код

//Некоторые языки программирования, такие как https://www.gnu.org/software/bash/[bash] или https://www.python.org/[Python], не компилируются в машинный код. Вместо этого исходный код их программ выполняется шаг за шагом, без предварительных преобразований,
//ifdef::community[https://en.wikipedia.org/wiki/Interpreter_%28computing%29[языковым интерпретатором]]
//ifdef::rhel[языковым интерпретатором]
//или языковой виртуальной машиной.

//Программное обеспечение, написанное полностью на интерпретируемых языках программирования, не зависит от
//ifdef::community[https://en.wikipedia.org/wiki/Microarchitecture[архитектуры]]
//ifdef::rhel[архитектуры]
//.
//Следовательно, результирующий пакет RPM будет иметь строку ``noarch`` в своем названии.

//Существует два типа интерпретируемых языков: языки, код которых *исполняется напрямую* и языки, код которых предварительно компилируется в *байт-код*. Процесс сборки программ для этих двух типов отличается.

//Интерпритируемые языки могут быть *байт-скомпилированными* или *напрямую интерпретированным*. Эти два
//типа отличаются процессом сборки программы и процедурой упаковки.

==== Программы с прямой интерпретацией
//Программы на языке с прямой интерпретацией вообще не нужно компилировать, они выполняются непосредственно интерпретатором.

==== Программы, скомпилированные в байт-код
//Программы, скомпилированные в байт-код, которые затем исполняются вируальной машиной соответствующего языка.

// NOTE: Некоторые языки предоставляют выбор: они могут быть напрямую интерпритированы или скомпилированы в байт-код.

// Эта разница отражается на процедуре упаковки. Некоторые языки дают выбор: они могут интерпретироваться напрямую или компилироваться в байт-код.

// Программное обеспечение, написанное полностью на интерпретируемых языках программирования, не зависит от https://en.wikipedia.org/wiki/Microarchitecture[архитектуры]. Следовательно, результирующий пакет RPM будет иметь строку ``noarch`` в своем названии.

[[building-software-from-source]]
== Сборка программного обеспечения из исходного кода
//// 
В этом разделе объясняется сборка программного обеспечения на основе его исходного кода.

* Для программного обеспечения, написанного на компилируемых языках, исходный код проходит процесс *сборки*, создавая машинный код. Этот процесс, обычно называемый *компиляцией* или *переводом*, различается для разных языков. Полученное в результате сборки программное обеспечение может быть *запущено* или "*выполнено*", что заставит компьютер выполнять задачу, поставленную программистом.
* Для программного обеспечения, написанного на прямо интерпретируемых языках, исходный код не компилируется, а выполняется напрямую.
* Для программного обеспечения, написанного на интерпретируемых языках с компиляцией в байт-код, исходный код компилируется в байт-код, который затем выполняется виртуальной машиной соответствующего языка.
//// 
[[natively-compiled-code-building-software-from-source]]
=== Изначально скомпилированный код
//// 
В этом примере вы создадите ``cello.c`` программу, написанную на языке
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
в исполняемый файл.

``cello.c``

[source,c]
----
#include <stdio.h>

int main(void) {
    printf("Hello World\n");
    return 0;
}

----
//// 
[[manual-building]]
==== Ручная сборка
//// 
Вызовите компилятор
ifdef::community[https://en.wikipedia.org/wiki/C_%28programming_language%29[C]]
ifdef::rhel[C]
из коллекции компиляторов GNU  (https://gcc.gnu.org/[GCC]) чтобы скомпилировать исходный код в бинарный файл:

[source,bash]
----
gcc -g -o cello cello.c

----

Запустите бинарный файл ``cello``.

[source,bash]
----
$ ./cello
Hello World

----

Вот и все. Вы создали и запустили изначально скомпилированное программное обеспечение из исходного кода.
//// 
==== Автоматическая сборка
////
Вместо того, чтобы создавать исходный код вручную, вы можете автоматизировать сборку. Это обычная практика, используемая в крупномасштабном программном обеспечении. Автоматизация сборки осуществляется путем создания  ``Makefile`` и последующим запуском утилиты
http://www.gnu.org/software/make/[GNU ``make``].

Чтобы настроить автоматическую сборку, создайте файл с именем  ``Makefile`` в том же каталоге, что и``cello.c``:

``Makefile``

[source,makefile]
----
cello:
        gcc -g -o cello cello.c

clean:
        rm cello

----

Теперь, чтобы собрать программу, просто запустите ``make``:

[source,bash]
----
$ make
make: 'cello' is up to date.

----

Посколько сборка уже создана, ``make clean`` очистит её, а затем снова запустит ``make``:

[source,bash]
----
$ make clean
rm cello

$ make
gcc -g -o cello cello.c

----

Опять же, попытка сборки после другой сборки ничего не даст:

[source,bash]
----
$ make
make: 'cello' is up to date.

----

Наконец, программа выполнится:

[source,bash]
----
$ ./cello
Hello World

----

Теперь Вы скомпилировали программу как вручную, так и с помощью инструмента сборки.
////

[[interpreted-code-building-software-from-source]]
=== Интерпретируемый код

//// 


Следующие два примера демонстрируют компиляцию в байт-код программы, написанной на
https://www.python.org/[Python] и прямую интерпретацию программы, написанной на
https://www.gnu.org/software/bash/[bash].

[NOTE]
====
В двух приведенных ниже примерах``#!`` строка в верхней части файла называется 
ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[shebang]]
ifdef::rhel[shebang]
и не является частью исходного кода.

ifdef::community[https://en.wikipedia.org/wiki/Shebang_%28Unix%29[shebang]]
ifdef::rhel[shebang]
позволяет использовать текстовый файл в качестве исполняемого файла: загрузчик системной программы анализирует строку, содержащую *shebang*, чтобы получить путь к бинарному исполняемому файлу, который затем используется в качестве интерпретатора языка программирования.
====
//// 


[[byte-compiled-code]]
==== Компиляция байт-кода
//// 
В этом примере Вы скомпилируете в  байт-код ``pello.py`` - программу, написанную на Python, который затем выполняется виртуальной машиной Python. Исходный код Python также может быть напрямую интерпретирован, но исполнение байт-кода быстрее. Следовательно, RPM упаковщики  предпочитают упаковывать скомпилированный байт-код для распространения среди конечных пользователей.

``pello.py``

[source,python]
----
#!/usr/bin/env python

print("Hello World")

----

Процедура программ в байт-код отличается для разных языков. Это зависит от языка, виртуальной машины языка, а также инструментов и процессов, используемых с этим языком.

NOTE: https://www.python.org/[Python] часто компилируется в байт-код, но не так, как описано здесь. Следующая процедура направлена не на то, чтобы соответствовать стандартам сообщества, а на то, чтобы быть простой. Для получения практических рекомендаций по Python см. раздел
https://docs.python.org/2/library/distribution.html[Упаковка и распространение программного обеспечения].

Компиляция ``pello.py`` в байт-код:

[source,bash]
----
$ python -m compileall pello.py

$ file pello.pyc
pello.pyc: python 2.7 byte-compiled

----

Выполните байт-код в ``pello.pyc``:

[source,bash]
----
$ python pello.pyc
Hello World

----

[[raw-interpreted]]
==== Напрямую интепретированный код

В этом примере Вы будете интерпретировать программу ``bello`` написанную на встроенном языке оболочки
https://www.gnu.org/software/bash/[bash].

``bello``

[source,bash]
----
#!/bin/bash

printf "Hello World\n"

----

Для программ, написанных на языках сценариев оболочки, таких как  _bash_, используется прямая интерпретация.
Следовательно, Вам нужно только сделать файл с исходным кодом исполняемым и запустить его:

[source,bash]
----
$ chmod +x bello
$ ./bello
Hello World

----
//// 
[[patching-software]]
== Программное обеспечение для исправления ошибок

**Patch** - это исходный код, который исправляет другой исходный код. Он отформатирован как __diff__, потому что представляет разницу между двумя версиями текста. Разница создаётся с помощью утилиты ``diff``, которая затем применяется к исходному коду с помощью утилиты http://savannah.gnu.org/projects/patch/[patch].

NOTE: Разработчики программного обеспечения часто используют системы контроля версий, такие как https://git-scm.com/[git], для управления своей кодовой базой. Такие инструменты предоставляют свои собственные методы создания различий или исправления программного обеспечения.

В следующем примере мы создаем исправление из исходного кода с помощью 
``diff``, а затем используем ``patch``. Исправление использует в следующих разделах при создании RPM и работе со .spec-файлом. xref:working-with-spec-files[Работа со SPEC файлами].
////
Как исправление связано с упаковкой RPM? В упаковке, вместо того, чтобы просто изменять исходный код, мы сохраняем его и используем на нем исправления.

Чтобы создать патч для ``cello.c``:

. Сохраним исходный код:
+
[source,bash]
----
$ cp cello.c cello.c.orig

----
+
Это наиболее распространённый способ сохранить файл исходного кода.
+
. Изменим``cello.c``:
+
[source,c]
----
#include <stdio.h>

int main(void) {
    printf("Hello World from my very first patch!\n");
    return 0;
}

----
+
. Сгенерируем патч используя утилиту ``diff``:
+
NOTE: Мы используем несколько общих аргументов для утилиты ``diff``. Для получения дополнительной информации о них см. руководство по использованию ``diff``.
+
[source,diff]
----
$ diff -Naur cello.c.orig cello.c
--- cello.c.orig        2016-05-26 17:21:30.478523360 -0500
+++ cello.c     2016-05-27 14:53:20.668588245 -0500
@@ -1,6 +1,6 @@
 #include<stdio.h>

 int main(void){
-    printf("Hello World!\n");
+    printf("Hello World from my very first patch!\n");
     return 0;
 }
----
+
Строки, начинающиеся с ``-`` удалятся из исходного кода и заменятся на строки, начинающихся с  ``+``.
+
. Сохраним патч в файл:
+
[source,bash]
----
$ diff -Naur cello.c.orig cello.c > cello-output-first-patch.patch
----
+
. Восстановим исходный код ``cello.c``:
+
[source,bash]
----
$ cp cello.c.orig cello.c
----
+
Мы сохраняем исходный файл ``cello.c``, потому что при создании RPM используется исходный файл, а не измененный. Дополнительные сведения см. в разделе
xref:working-with-spec-files[Работа со SPEC файлами].

Чтобы исправить ``cello.c`` с помощью ``cello-output-first-patch.patch``, перенаправьте патч-файл ``patch`` коммандой:

[source,bash]
----
$ patch < cello-output-first-patch.patch
patching file cello.c
----

Содержимое ``cello.c`` теперь отражает изменения:

[source,bash]
----
$ cat cello.c
#include<stdio.h>

int main(void){
    printf("Hello World from my very first patch!\n");
    return 0;
}
----

Чтобы собрать и запустить отредактированную ``cello.c``:

[source,bash]
----
$ make clean
rm cello

$ make
gcc -g -o cello cello.c

$ ./cello
Hello World from my very first patch!
----

Вы создали патч, отредактировали программу, собрали отредактированную программу и запустили её.
////

[[installing-arbitrary-artifacts]]
== Установка Произвольных Артефактов
////
Большим преимуществом
ifdef::community[https://en.wikipedia.org/wiki/Linux[Linux]]
ifdef::rhel[Linux]
и других Unix-подобных систем является 
ifdef::community[https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard[Стандарт иерархии файловой системы]]
ifdef::rhel[Стандарт иерархии файловой системы] 
. Он указывает, в каком каталоге должны быть расположены файлы. 
Файлы, установленные из пакетов RPM, должны быть размещены в соответствии с ИФС. Например, исполняемый файл должен находиться в каталоге, который находится в переменной 
ifdef::community[https://en.wikipedia.org/wiki/PATH_%28variable%29[PATH]]
ifdef::rhel[PATH]
.


В контексте этого руководства, __Произвольный артефакт__ - это все, что устанавливается из RPM в систему. Для RPM и для системы это может быть скрипт, бинарный файл, скомпилированный из исходного кода пакета, предварительно скомпилированный бинарный файл или любой другой файл.
////
Мы рассмотрим два популярных способа размещения __произвольных артефактов__ в системе: с помощью команды ``install`` и с помощью команды ``make install``.


[[install-command]]
=== Использование команды install

Иногда с помощью инструментов автоматизации сборки, таких как
http://www.gnu.org/software/make/[GNU make] не является оптимальным - например, если упакованная программа проста. В этих случаях упаковщики часто используют команду ``install`` (предоставляемая системе
http://www.gnu.org/software/coreutils/coreutils.html[coreutils]), которая помещает артефакт в указанный каталог в файловой системе с указанным набором разрешений.

В приведенном ниже примере будет использоваться файл ``bello``,  который мы ранее создали в качестве произвольного артефакта, зависящего от нашего метода установки.  Обратите внимание, что Вам либо понадобятся разрешения  http://www.sudo.ws/[sudo], либо запустите эту команду от имени root, исключая часть команды ``sudo``.

В этом примере ``install`` помещает файл ``bello`` в ``/usr/bin`` с разрешениями, общими для исполняемых скриптов:

[source,bash]
----
$ sudo install -m 0755 bello /usr/bin/bello

----

Теперь``bello`` находится в каталоге, который указан в переменной 
ifdef::community[https://en.wikipedia.org/wiki/PATH_%28variable%29[$PATH]]
ifdef::rhel[$PATH]
. Таким образом, Вы можете запустить ``bello`` из любого каталога, не указывая его путь:

[source,bash]
----
$ cd ~

$ bello
Hello World

----

[[make-install]]
=== Использование команды make install

Популярным автоматизированным способом установки программного обеспечения в систему является использование команды ``make install``. Вы указываете, как установить произвольные артефакты в систему в файле ``Makefile``.

NOTE: Обычно ``Makefile`` пишется разработчиком, а не упаковщиком. 

Добавьте секцию ``install`` в ``Makefile``:

``Makefile``

[source,makefile]
----
cello:
        gcc -g -o cello cello.c

clean:
        rm cello

install:
        mkdir -p $(DESTDIR)/usr/bin
        install -m 0755 cello $(DESTDIR)/usr/bin/cello

----

Переменная https://www.gnu.org/software/make/manual/html_node/DESTDIR.html[$(DESTDIR)]
является встроенной в  http://www.gnu.org/software/make/[GNU make] и обычно используется для указания установки в каталог, отличный от корневого каталога.

Теперь вы можете использовать ``Makefile`` не только для сборки программного обеспечения, но и для его установки в систему.


Для сборки и установки программы ``cello.c``:

[source,bash]
----
$ make
gcc -g -o cello cello.c

$ sudo make install
install -m 0755 cello /usr/bin/cello

----

Теперь``cello`` находится в каталоге, который указан в переменной
ifdef::community[https://en.wikipedia.org/wiki/PATH_%28variable%29[$PATH]]
ifdef::rhel[$PATH]
. Таким образом, Вы можете запустить ``cello`` из любого каталога, не указывая его полный путь. 

[source,bash]
----
$ cd ~

$ cello
Hello World

----

Вы установили артефакт сборки в выбранное место в системе.

[[preparing-source-code-for-packaging]]
== Подготовка исходного кода для упаковки

NOTE: Код, созданный в этом разделе, можно найти
https://github.com/redhat-developer/rpm-packaging-guide/tree/master/example-code[здесь].

Разработчики часто распространяют программное обеспечение в виде сжатых архивов исходного кода, которые затем используются для создания пакетов. В этом разделе Вы создадите такие архивы.

NOTE: Создание архивов исходного кода обычно выполняется не RPM-упаковщиком, а разработчиком. Упаковщик работает с готовым архивом исходного кода.

Программное обеспечение должно распространяться с 
https://en.wikipedia.org/wiki/Software_license[лицензией]
. Для примера мы будем использовать лицензию 
https://www.gnu.org/licenses/quick-guide-gplv3.html[GPLv3]. Текст лицензии помещается в файл ``LICENSE`` для каждой из примеров программ. Упаковщику RPM необходимо иметь дело с файлами лицензий при упаковке.

Для использования со следующими примерами создайте файл  ``LICENSE``:

[source,bash]
----
$ cat /tmp/LICENSE
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

----

[[putting-source-code-into-tarball]]
== Создание Tarball с исходным кодом

В приведенных ниже примерах мы помещаем каждую из трех программ  ``Hello World`` в архив, сжатый с помощью
https://www.gnu.org/software/gzip/[gzip]. Программное обеспечение часто выпускается таким образом, чтобы позже быть упакованным для распространения.

[[bello]]
=== bello

Проект __bello__ реализует ``Hello World`` в
https://www.gnu.org/software/bash/[bash]. Реализация содержит только сценарий оболочки ``bello``, поэтому результирующий архив ``tar.gz`` будет содержать только один файл, кроме файла  ``LICENSE``. Давайте предположим, что это версия программы - ``0.1``

Подготовьте проект __bello__ для распространения:

. Поместите файлы в один каталог:
+
[source,bash]
----
$ mkdir /tmp/bello-0.1

$ mv ~/bello /tmp/bello-0.1/

$ cp /tmp/LICENSE /tmp/bello-0.1/

----

. Создайте архив для распространения и переместите его в ``~/rpmbuild/SOURCES/``:
+
[source,bash]
----
$ cd /tmp/

$ tar -cvzf bello-0.1.tar.gz bello-0.1
bello-0.1/
bello-0.1/LICENSE
bello-0.1/bello

$ mv /tmp/bello-0.1.tar.gz ~/rpmbuild/SOURCES/

----

[[pello]]
=== pello

Проект __pello__ реализует ``Hello World`` на
https://www.python.org/[Python]. Реализация содержит только программу
``pello.py``, так что результирующий архив ``tar.gz`` будет содержать только один файл, кроме файла  ``LICENSE``. Предположим, что это версия программы -
``0.1.1``

Подготовьте проект __pello__ для распространения:

. Поместите файлы в один каталог:
+
[source,bash]
----
$ mkdir /tmp/pello-0.1.1

$ mv ~/pello.py /tmp/pello-0.1.1/

$ cp /tmp/LICENSE /tmp/pello-0.1.1/

----

. Создайте архив для распространения и переместите его в ``~/rpmbuild/SOURCES/``:
+
[source,bash]
----
$ cd /tmp/

$ tar -cvzf pello-0.1.1.tar.gz pello-0.1.1
pello-0.1.1/
pello-0.1.1/LICENSE
pello-0.1.1/pello.py

$ mv /tmp/pello-0.1.1.tar.gz ~/rpmbuild/SOURCES/

----

[[cello]]
=== cello

Проект __cello__ реализует ``Hello World`` на
ifdef::community[https://ru.wikipedia.org/wiki/Си_(язык_программирования)[C]]
ifdef::rhel[C]
. Реализация содержит только файлы ``cello.c`` и
``Makefile``, поэтому результирующий архив ``tar.gz``  будет содержать только два файла, помимо файла ``LICENSE``. Давайте предположим, что это версия программы - ``1.0``

Обратите внимание, что ``patch`` не распространяется в архиве вместе с программой. 
Упаковщик RPM применяет исправление при создании RPM. Патч будет помещен в каталог ``~/rpmbuild/SOURCES/`` рядом с ``.tar.gz`` архивом.

Подготовьте проект __cello__ для распространения:


. Поместите файлы в один каталог:
+
[source,bash]
----
$ mkdir /tmp/cello-1.0

$ mv ~/cello.c /tmp/cello-1.0/

$ mv ~/Makefile /tmp/cello-1.0/

$ cp /tmp/LICENSE /tmp/cello-1.0/

----

. Создайте архив для распространения и переместите его в  ``~/rpmbuild/SOURCES/``:
+
[source,bash]
----
$ cd /tmp/

$ tar -cvzf cello-1.0.tar.gz cello-1.0
cello-1.0/
cello-1.0/Makefile
cello-1.0/cello.c
cello-1.0/LICENSE

$ mv /tmp/cello-1.0.tar.gz ~/rpmbuild/SOURCES/

----

. Добавьте патч:
+
[source,bash]
----
$ mv ~/cello-output-first-patch.patch ~/rpmbuild/SOURCES/

----

Теперь исходный код готов к упаковке в RPM.
